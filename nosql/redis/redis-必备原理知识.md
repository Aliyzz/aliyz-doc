# Redis 原理分析

-----


## 槽是什么

- https://www.cnblogs.com/rjzheng/p/11430592.html
- https://www.cnblogs.com/rjzheng/p/10360619.html

#### Why is 16384？

> 2^14 = 16384 = 2k <br>
>
> Redis主要使用形式是 **`Redis Cluster`** ，节点之间连接先要握手🤝，握手成功后节点间 ***定期*** 发送 **ping/pong** 消息，交换数据信息（哦哦...你还活着啊！！）；`消息=消息头+消息体` ，消息体就不说了，消息头里面有个属性叫 ***myslots*** （char数组，长度为16383/8，这其实是一个bitmap,每一个位代表一个槽，如果该位为1，表示这个槽是属于这个节点的），它是最占内存的，
>> - 所以如果槽位=65536，发送心跳的消息头达8k，占用带宽；<br>
>> - 集群中节点数量过多，心跳流量会很大，导致网络拥堵；<br>
>> - 槽位越小，节点少越少，压缩比高（消息在传输过程中是经过压缩的）。


## 单线程怎么说





## RDB/AOF

#### 认识一下

- Redis两种持久化方式
- 用于数据的 **冷备** 和 **热备**，也用于数据迁移等

#### RDB （Redis DataBase）

- **是什么**？

> Redis 默认的持久化方案。<br>
> 在指定的时间间隔内，执行指定次数的写操作，则会将内存中的数据写入到磁盘中。即在指定目录下生成一个dump.rdb文件。Redis 重启会通过加载dump.rdb文件恢复数据。

- **原理**

> 一面看就是：***内存快照*** ，另一面看就是：***fork｜COW***
>> - fork：他是 `glibc ` 的一个函数，基于当前进程 复制 一个进程，主进程和子进程会共享内存里面的代码块和数据段；**子进程**完成快照持久化，**父进程**处理客户端请求。
>> - cow（Copy On Write）机制：他是操作系统的机制，进行数据段页面的分离。数据段是由很多操作系统的页面组合而成，当父进程对其中一个页面的数据进行修改时，会将被共享的页面复 制一份分离出来，然后 对这个复制的页面进行修改。这时 子进程 相应的页面是 没有变化的，还是进程产生时那一瞬间的数据。

- **触发时机**

> 在指定的时间间隔内，执行指定次数的写操作<br>
> 执行save（阻塞， 只管保存快照，其他的等待） 或者是bgsave （异步）命令<br>
> 执行flushall 命令，清空数据库所有数据，意义不大<br>
> 执行shutdown 命令，保证服务器正常关闭且不丢失任何数据，意义...也不大

- **特点**

> 适合大规模的数据恢复<br>
> 适合对数据完整性和一致性要求不高的场景<br>
> 备份时创建子进程，增加开销，占用内存


#### AOF （Append Only File）

- **是什么**？

> Redis 默认不开启。<br>
> 它的出现是为了弥补RDB的不足（数据的不一致性），所以它采用日志的形式来记录每个写操作，并追加到文件中。Redis 重启 **重放** 文件中的命令实现数据恢复。

- **原理**

> Redis将写操作追加到文件，如：appendonly.aof；当AOF文件的大小超过所设定的阈值时，Redis就会对AOF文件的内容压缩，即重写（👇）。<br>
> 
> **重写的原理**：Redis 会fork出一条新进程，读取内存中的数据，并重新写到一个临时文件中。并没有读取旧文件（你都那么大了，我还去读你？？？傻啊！）。最后替换旧的aof文件。
> 
> 触发机制：当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。这里的“一倍”和“64M” 可以通过配置文件修改。

- **特点**

> 数据的完整性和一致性更高
> 文件比较大时，相对RDB数据恢复慢


## 淘汰机制



















