# Redis 原理分析

-----


## 槽是什么

- https://www.cnblogs.com/rjzheng/p/11430592.html
- https://www.cnblogs.com/rjzheng/p/10360619.html

#### 前言

> 客户端请求的key，根据公式 **`HASH_SLOT=CRC16(key) mod 16384`** ，计算出映射到哪个分片上，然后Redis会去相应的节点进行操作！
> 
> **`CRC16`** 算法产生的hash值有16bit，该算法可以产生 2^16-=65536 个值。换句话说，值是分布在0~65535之间。那作者在做mod运算的时候，为什么不mod 65536，而选择mod 16384？<br>
>> **循环冗余校验（Cyclic Redundancy Check， CRC）** 是一种根据网络数据包或计算机文件等数据产生简短固定位数校验码的一种 `信道编码技术`，主要用来检测或校验数据传输或者保存后可能出现的错误。它是利用除法及余数的原理来作错误侦测的。

#### Why is 16384？

> 2^14 = 16384 = 2k <br>
>
> Redis主要使用形式是 **`Redis Cluster`** ，节点之间连接先要握手🤝，握手成功后节点间 ***定期*** 发送 **ping/pong** 消息，交换数据信息（哦哦...你还活着啊！！）；`消息=消息头+消息体` ，消息体就不说了，消息头里面有个属性叫 ***myslots*** （char数组，长度为16383/8，这其实是一个bitmap,每一个位代表一个槽，如果该位为1，表示这个槽是属于这个节点的），它是最占内存的，
>> - 所以如果槽位=65536，发送心跳的消息头达8k，占用带宽；<br>
>> - 集群中节点数量过多，心跳流量会很大，导致网络拥堵；<br>
>> - 槽位越小，节点少越少，压缩比高（消息在传输过程中是经过压缩的）。


## 单线程怎么说

#### 为什么选用单线程

> - 官方FAQ表示，因为Redis是基于内存的操作，**`CPU不是Redis的瓶颈`**，Redis的瓶颈最有可能是机器**`内存的大小`**或者**`网络带宽`**。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。<br>
> - 单线程避免了不必要的上下文切换和竞争条件，减少内耗；不用考虑各种锁的问题。

```markdown
**扩展** 什么时候用多线程的方案？
> 答案是：下层的存储等慢速的情况
```

#### 实现原理

- I/O多路复用（事件驱动）

> 操作系统的这个功能是通过 **`select/poll/epoll/kqueue/evport`** 之类的系统调用函数来实现，这些函数都可以同时监视多个描述符的读写就绪状况，这样，多个描述符的I/O操作都能在一个线程内并发交替地顺序完成，这就叫I/O多路复用；
>
> “多路”指的是多个网络连接，“复用”指的是复用同一个处理线程；
> 
> 它的特点是可以让单个线程高效的处理多个连接请求；

- Redis实现

https://www.jianshu.com/p/603de8774734

> Redis的I/O多路复用模块的功能都是封装了操作系统提供的 select、epoll、evport、kqueue 这些基础函数。向上层提供了一个统一的接口,屏蔽了底层实现的细节。每个I/O多路复用函数库在Redis源码中都对应一个单独的文件。
> 
> 事件 <br>
>> **文件事件**：基于Reactor模式开发，Redis服务器通过监听Socket产生的文件事件并处理这些事件实现对客户端的响应。<br>
>> **时间事件**：Redis服务器的某些操作需要在给定的时间点执行,而时间事件就是服务器对这类定时操作的对象，如：定时RDB、内存清理等。

#### 金无足赤

> - 单线程，同一时刻只有一个操作在进行，耗时的命令会导致并发（读并发/读并发写）的下降；<br>
> - 单线程，同一时刻也只能用到一个CPU核心，多核机器CPU浪费（通过起多个实例补救，master-master或master-slave）；<br>
> 
>> ⚠️默认情况下单线程在进行系统调用的时候会**随机使用CPU内核**，为了优化Redis，我们可以使用工具为单线程绑定固定的CPU内核，减少不必要的性能损耗！`Linux 上 taskset 可以将某个进程绑定到一个特定的CPU`。


## RDB/AOF

#### 认识一下

- Redis两种持久化方式
- 用于数据的 **冷备** 和 **热备**，也用于数据迁移等

### RDB （Redis DataBase）

- **是什么**？

> Redis 默认的持久化方案。<br>
> 在指定的时间间隔内，执行指定次数的写操作，则会将内存中的数据写入到磁盘中。即在指定目录下生成一个dump.rdb文件。Redis 重启会通过加载dump.rdb文件恢复数据。

- **原理**

> 一面看就是：***内存快照*** ，另一面看就是：***fork｜COW***
>> - fork：他是 `glibc ` 的一个函数，基于当前进程 复制 一个进程，主进程和子进程会共享内存里面的代码块和数据段；**子进程**完成快照持久化，**父进程**处理客户端请求。
>> - cow（Copy On Write）机制：他是操作系统的机制，进行数据段页面的分离。数据段是由很多操作系统的页面组合而成，当父进程对其中一个页面的数据进行修改时，会将被共享的页面复 制一份分离出来，然后 对这个复制的页面进行修改。这时 子进程 相应的页面是 没有变化的，还是进程产生时那一瞬间的数据。

- **触发时机**

> 在指定的时间间隔内，执行指定次数的写操作<br>
> 执行save（阻塞， 只管保存快照，其他的等待） 或者是bgsave （异步）命令<br>
> 执行flushall 命令，清空数据库所有数据，意义不大<br>
> 执行shutdown 命令，保证服务器正常关闭且不丢失任何数据，意义...也不大

- **特点**

> 适合大规模的数据恢复<br>
> 适合对数据完整性和一致性要求不高的场景<br>
> 备份时创建子进程，增加开销，占用内存


### AOF （Append Only File）

- **是什么**？

> Redis 默认不开启。<br>
> 它的出现是为了弥补RDB的不足（数据的不一致性），所以它采用日志的形式来记录每个写操作，并追加到文件中。Redis 重启 **重放** 文件中的命令实现数据恢复。

- **原理**

> Redis将写操作追加到文件，如：appendonly.aof；当AOF文件的大小超过所设定的阈值时，Redis就会对AOF文件的内容压缩，即重写（👇）。<br>
> 
> **重写的原理**：Redis 会fork出一条新进程，读取内存中的数据，并重新写到一个临时文件中。并没有读取旧文件（你都那么大了，我还去读你？？？傻啊！）。最后替换旧的aof文件。
> 
> 触发机制：当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。这里的“一倍”和“64M” 可以通过配置文件修改。

- **特点**

> 数据的完整性和一致性更高
> 文件比较大时，相对RDB数据恢复慢

## 过期策略

> 顾名思义，Redis针对过期的 key 使用的清除策略。
> 
> - **定期删除（主动）**：Redis定期（默认每隔100ms，可配置）**随机抽取** 进行一定数量（默认100，也可配置）的 key 检查，如果过期，则清除；这个过程中，如果过期的 key 超过一定的比例（默认25%，还是可配置...是不是很灵活😄），则再会进行一次抽取、检查、删除、过期比例.....
> - **惰性删除**：客户端查询一个 key 时，Redis会检查该 key 是否已过期，如果过期则删除。


## 淘汰机制

#### **存在即合理**

> 由于Redis定期删除是随机抽取检查，不可能扫描清除掉所有过期的key并删除，然后一些key由于未被请求，惰性删除也未触发，***这样Redis的内存占用会越来越高***，此时就需要内存淘汰机制。

#### **触发**

> Redis配置文件中可以使用 **`maxmemory <bytes>`** 将内存使用限制设置为指定的字节数，当达到内存限制时，Redis会根据选择的淘汰策略来删除 key；<br>
> 如果设置为 0 的时候表示我们对Redis的内存使用没有限制。

#### **8 种淘汰策略**

```markdown
**LRU** 的意思是：Least Recently Used 最近最少使用
**LFU** 的意思是：Least Frequently Used 最近最不常用
```

> - ***noeviction*** --> Don't evict anything, just return an error on write operations.<br>
> 不要删除任何东西，只是在写操作上返回一个错误。***`（默认）`***
> 
> - ***volatile-lru*** --> Evict using approximated LRU among the keys with an expire set.<br>
> 在带有过期时间的键中选择最近最少使用的。***（推荐）***
>
> - ***allkeys-lru*** --> Evict any key using approximated LRU.<br>
> 在所有的键中选择最近最少使用的。（不区分是否携带过期时间）***（一般推荐）***
> 
> - *volatile-lfu* --> Evict using approximated LFU among the keys with an expire set.<br>
> 在带有过期时间的键中选择最不常用的。
> 
> - *allkeys-lfu* --> Evict any key using approximated LFU.<br>
> 在所有的键中选择最不常用的。（不区分是否携带过期时间）
> 
> - *volatile-random* --> Remove a random key among the ones with an expire set.<br>
> 在带有过期时间的键中随机选择。
> 
> - *allkeys-random* --> Remove a random key, any key.<br>
> 在所有的键中随机选择。
> 
> - *volatile-ttl* --> Remove the key with the nearest expire time (minor TTL).<br>
> 在带有过期时间的键中选择过期时间最小的。
> 
> 
> 配置文件中 `# maxmemory-policy <policy>` 配置将要使用的策略.

#### **如何选择**

> - allkeys-lru <br>
>  如果我们的应用对缓存的访问符合幂律分布（也就是存在相对热点数据），或者我们不太清楚我们应用的缓存访问分布状况；另一方面，将key设置过期时间实际上**会消耗更多的内存**，该策略会更有效率的使用内存；
> 
> - allkeys-random <br>
> 如果我们的应用对于缓存key的访问概率相等，则可以使用这个策略；
> 
> - volatile-ttl <br>
> 这种策略使得我们可以向Redis提示哪些key更适合被eviction；
> 
> - volatile-lru/volatile-random <br>
> 适合我们将一个Redis实例既应用于缓存和又应用于持久化存储的时候，然而我们也可以通过使用两个Redis实例来达到相同的效果。







