# Redis 高级数据类型

----



## HyperLogLog

#### 问题原形

>如果要实现这么一个功能：
>
>```
统计 APP或网页 的一个页面 UV（网站独立访客）数。
>```

#### 当前选择

>1.HashMap：满足去重，操作简单；但是数据量过大内存成问题。<br>
>2.B+树、Bitmap位图（先不介绍）。<br>
>3.***HyperLogLog***：下面简称为HLL，它是 LogLog 算法的升级版，作用是能够提供不精确的去重计数。存在以下的特点：
>>- 代码实现较难；
>>- 能够使用极少的内存来统计巨量的数据，在 Redis 中，只需要12K内存就能统计2^64个数据（***难点***）；
>>- 计数存在一定的误差，误差率整体较低，标准误差为 0.81% ；
>>- 误差可以被设置辅助计算因子进行降低。

#### 理论基础

- **伯努利试验**

>它是数学概率论中的一部分内容，典故来源于抛硬币：<br>
>
```markdown
硬币拥有正反两面，一次的上抛至落下，最终出现正反面的概率都是50%；
假设一直抛硬币，直到它出现正面为止，`抛掷次数记为：k(i)，i=1,2,3,...,n`，
我们记录为一次完整的试验；
这个试验就是 **「伯努利试验」**。
```

- 计算公式

>上述实验中，n 为所进行的试验次数，下面的公式只是近似，Redis的HLL比这个要复杂得多（以后讲解）。

```python
								n = 2^max(k)
```


#### 命令使用

```python
# 添加（多个）元素
PFADD key [element ...]
说明：如果key不存在，则新建一个empty HLL；如果HLL内部寄存器发生变化，返回1；否则返回0；
	
# 获取统计值
PFCOUNT key [key ...]
说明：
a.参数是单个key时，如果key存在，返回基数估算值，否则返回0；
b.参数是多个key，内部将多个HLL merge后，返回基数估算的值
	
# 将多个HLL合并存储到另一个HLL，如果目标key不存在，则创建
PFMERGE destkey sourcekey [sourcekey ...]
```



## Bitmaps


#### 理解位图

>现代计算机用二进制（位） 作为信息的基础单位， 1个字节等于8位， 例如“big”字符串是由3个字节组成， 但实际在计算机存储时将其用二进制表示， “big”分别对应的ASCII码分别是98、 105、 103， 对应的二进制分别是01100010、01101001和01100111<br><br>
>合理地使用位能够有效地提高内存使用率和开发效率，Redis位图应该这么理解：<br>
>>- Bitmaps本身不是一种数据结构，实际上它就是字符串，但是它可以对字符串的位进行操作；
>>- Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做 **偏移量（offset）**；
>>- Bitmaps的**最大优势是节省存储空间**。例如，在一个以自增id代表不同用户的系统中，我们只需要512MB空间就可以记录40亿用户的某个单一信息（比如，用户是否希望接收新闻邮件）。

#### 命令使用

```python
# 设置值
SETBIT key offset value

# 获取值
GETBIT key offset
```

#### 使用场景

- 各种实时分析(Real time analytics of all kinds)；
- 存储与对象ID关联的布尔信息，要求高效且高性能(Storing space efficient but high performance boolean information associated with object IDs.)；
- 布隆过滤器。



## Pub/Sub

>发布/订阅模式，它是一种消息传递的模式；它包含两种角色，分别是 ***发布者*** 和 ***订阅者*** 。订阅者可以订阅 **一个或者多个频道(channel)**，而发布者可以向指定的频道(channel)发送消息，所有订阅此频道的订阅者都会收到此消息。

#### 普通的发布/订阅

- 命令使用

```python
# 发布消息
PUBLISH channel message

# 订阅（多个频道）消息
SUBSCRIBE channel [channel ...]
说明：
1、订阅者不会收到订阅之前就发布到该频道的消息

# 按照规则订阅消息
PSUBSCRIBE pattern [pattern ...]
说明：
1、规则支持通配符格式，通配符中 ? 表示1个占位符，* 表示任意个占位符(包括0)，?* 表示1个以上占位符

# 退订指定的频道
UNSUBSCRIBE channel [channel ...]

# 退订指定的规则
PUNSUBSCRIBE [pattern [pattern ...]]
说明：
1、如果没有参数则会退订所有规则
```

>使用punsubscribe只能退订通过psubscribe命令订阅的规则，不会影响直接通过subscribe命令订阅的频道；同样unsubscribe命令也不会影响通过psubscribe命令订阅的规则<br>
>
>另外需要注意punsubscribe命令退订某个规则时不会将其中的通配符展开，而是进行***严格的字符串匹配***，所以punsubscribe \* 无法退订c\*规则，而是必须使用punsubscribe c\*才可以退订。


- 使用场景

	- 用作实时消息系统，比如普通的即时聊天，群聊等功能；

	
## Transactions

>**是什么**： 可以一次执行多个命令，本质是一组命令的集合。一个事务中的所有命令都会序列化，按顺序串行化的执行而不会被其他命令插入。可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。
>
>**能干嘛**： 一个*队列中*，**一次性**、**顺序性**、**排他性**的执行一系列命令 (要和pipeline区分开)。
>
>**特点**：单个 Redis ***命令的执行是原子性的***，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis ***事务的执行并不是原子性的***。

#### 事物过程

- 开始事务
- 命令入队
- 执行事务

#### 重要保证

- 批量操作在发送 EXEC 命令前被放入队列缓存。
- 收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。
- 在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。

#### 命令使用

```python
# 开始事务
MULTI

# 触发事务
EXEC

# 取消事务
DISCARD

# 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断
WATCH key [key ...]

# 取消 WATCH 命令对所有 key 的监视
UNWATCH
```


## Geo（以后补充）
