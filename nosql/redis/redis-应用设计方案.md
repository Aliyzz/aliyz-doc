# Redis 应用设计方案

-----



## 分布式锁

#### 是什么

> 在分布式架构下，保证进程（服务）并发安全的一种锁机制，这个锁在进程之间共享，并且同一时刻只能由一个进程获得和释放该锁；
> 
> 分布式锁一般采用第三方消息中间件实现，如：Redis、Zookeeper等。

#### 特性保证

1. 要保证某个时刻中只有一个服务的一个方法获取到这个锁，即 ***互斥***
2. 要保证是 ***可重入锁*** (避免死锁)
3. 要保证锁的 **获取** 和 **释放** 的高可用

#### 注意什么

1. 锁超时处理 *`「可以给锁延期」`*
2. 拥有锁的进程下线怎么处理 *`「给锁设置合适的过期时间」`*
3. 集群master-slave架构的主从异步复制，由于master宕机，可能导致多个客户端同时完成加锁
4. 加锁的原子性保证 *`Redis 使用LUA脚本，SETNX+EXPIRE不能避免死锁`*

#### Redis的实现

1. Redisson框架
2. spring-integration-redis中 RedisLockRegistry 实现


## 消息队列

#### 基于List实现

- RPUSH + LPOP 组合（或 LPUSH + RPOP）

> List支持多个生产者和消费者并发进出消息，每个消费者拿到都是不同的列表元素。<br>
> 但是当队列为空时，lpop和rpop会一直 **空轮训，消耗资源**；所以引入阻塞读blpop和brpop（b代表blocking），***阻塞读在队列没有数据的时候进入休眠状态，一旦数据到来则立刻醒过来，消息延迟几乎为零***；<br>
>> ***空闲连接的问题***：如果线程一直阻塞在那里，Redis客户端的连接就成了闲置连接，闲置过久，服务器一般会主动断开连接，减少闲置资源占用，这个时候blpop和brpop或抛出异常，所以在编写客户端消费者的时候要小心，如果捕获到异常，还有重试。<br>
>
> ***缺点***：<br>
>> a.不能保证消费者消费消息后是否成功处理的问题 <br>
>> b.不能做广播模式 <br>
>> c.不能重复消费，一旦消费就会被删除 <br>
>> d.不支持分组消费

#### 基于Sorted-Set的实现

> Score排序的特征，就可以制作一个 ***有序消息队列***
> 
> ***使用场景***
> 
>> 有序集合的方案是在自己确定消息顺ID时比较常用，使用集合成员的Score来作为消息ID，保证顺序，还可以保证消息ID的单调递增；通常可以使用 `时间戳+序号` 的方案<br>
>
> ***优点***
> 
>> 可以自定义消息ID，在消息ID有意义时，比较重要
>
> ***缺点***
> 
>> 不允许重复消息（因为是集合），同时消息ID确定有错误会导致消息的顺序出错

#### 基于Stream的实现

> Stream是Redis 5.0引入的一种新数据类型，允许消费者等待生产者发送的新数据，还引入了消费者组概念，组之间数据是相同的（前提是设置的偏移量一样），组内的消费者不会拿到相同数据。这种概念和kafka很雷同。（***以后补充***）
> 
> https://my.oschina.net/u/3049601/blog/1822884